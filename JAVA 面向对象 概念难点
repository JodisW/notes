面向对象是相对于面向过程来讲，把相关数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

面向对象更灵活，复用性更高


**对象创建内存**
**栈 stack**
	- 存储特点：先进后出
	- 存储速度快：‘栈指针’向下移动，会创建新的内存，向上移动，会释放这部分内存。
	- 存储的是基本数据类型的数据，以及，引用数据类型的引用。
		○ Int a =10;
		○ Person p = new Person();


堆：
	- 存放的是类的对象
	- 所有类的对象都是通过new关键字创建: 告诉JVM , 需要明确的去创建一个新的对象 , 去开辟一块新的堆内存空间 
	- 内存的释放由GC(垃圾回收器)完成 

构造方法
	- 用于对象初始化
	- 执行于：在创建对象时，自动调用
	- 特点：
		○ 所有的Java类中都会至少存在一个构造方法
		○ Default，编译器会自动生成一个无参的构造方法, 构造方法中无代码
		Emp(){}
	- 格式：
		○ 与普通方法基本相同, 区别在于: 方法名称必须与类名相同, 没有返回值类型的声明 
		public Person(){
			Xxx;
		} 

方法的重载Overload：
	- 当方法名称相同
	- 不同：参数列表类型、参数列别长度、参数类型顺序不同
	- 无关：与返回值无关。

构造方法的重载：
	- 一个类，可以存在多个构造方法
	- 不同：参数列表类型、参数列别长度
	- 用法：可以在不同的创建对象的需求下, 调用不同的方法来完成对象的初始化！

匿名对象：
	- 注意：只使用一次的对象可以通过匿名对象的方式完成 



封装：
	- 意义：
		○ 用来保护或防止代码（数据）被无意破坏。
		○ 保护成员属性，不让类以外的程序直接访问和修改；
	- 原则：
		○ 隐藏对象的属性和实现细节
		○ 仅对外公开访问方法
		○ 并且控制访问级别
	
	Private - 访问权限词
			§ 
			
	
	This - 当前对象（用于构造方法中的传参）
			§ 调用类中的属性
			§ 调用类中的方法或构造方法
				□ 在一个构造方法中，调用另一个构造方法时，调用的代码必须编写在构造方法的第一行
				□ 表示当前对象
	 
	Static
	- 被修饰的方法、变量不需要依赖于对象来进行调用
	- 在类加载时加载并初始化，可通过类名进行访问
	- 在内存中只有一份( 为所有对象公用 ) 
	- 在访问时: static不能访问非静态 , 非静态可以访问static ! 




权限修饰符：
* 	Public
* 		○ 可跨包访问
* 	
* 	Protected
* 		○ 不能跨包
* 		
* 	Default
* 		○ 不能访问子类、跨包
* 	
* 	Private
* 		○ 仅限于类中使用
* 		○ 创建getter，setter
	

构造代码块
	- 在class中
	- 在每次对象创建时，执行一次， 执行在构造方法之前。 
	- 区别于构造方法：
		○ 无论用户调用哪一个构造方法来创建对象，构造代码块都必然执行。
{
	System.out.prinln("xxx");
}



**静态代码块**
	- 随着类的加载（第一次使用），静态代码块执行。
	- 因为类只加载一次，只执行一次
Static {
	System.out.prinln("xxx");
}

**执行顺序：**
**静态代码块 --> 构造代码块 --> 构造方法 **




继承
允许创建分等级层次的类。
	- 继承特征、方法
	- 格式：
		Class 子类 extends 父类 {}
		Class Student extends Person {}

	- 限制：
		○ Java中只有单继承、多重继承，没有多继承（但C++有）
	- 创建子类对象时，会先创建父class，父class作为子class的super存在
		○ 子调用父的setAge：
		S.setAge == s.super.setAge 
	- 创建子class时，default父class有无参构造方法，if not，要有super

Super：
	- 通过super，可访问：
		○ 父类的构造方法
			§ 必须写在子class构造方法的第一行
		○ 父类的属性
		○ 父类的方法

重写Override：
当子继承父的方法时，某方法不适合子，在子类中重写一遍该方法。
	- 规则：
		○ 传参：参数列表必须与被重写方法的相同
		○ 返回类型需相同
		○ 访问权限：子class的不能低于父class
		○ static和private的方法不能被重写
			§ 但能被再次声明

Override和Overload区别：
	1. 发生的位置：
		a. 重载：一个class中
		b. 重写：子父类中
	2. 参数列表限制：
		a. 重载：必须不同
		b. 重写：必须相同
	3. 返回值类型：
		a. 重载：无关
		b. 重写：返回值类型必须一致
	4. 访问权限：
		a. 重载：无关
		b. 重写：子class的不能低于父class
	5. 异常处理：
		a. 重载：与异常无关
		b. 重写：异常范围可以更小，但是不能抛出新的异常
	

final关键字
	- 用于修饰属性、变量：
		○ 变量成常量，无法再次赋值
			§ 局部变量，只能赋值一次（可以先声明后赋值）
			§ 成员属性，必须在声明时赋值
			§ 全局常量 public static final
			§ 命名规范：SQL-INSERT
	- 修饰类：
		○ 不可以被继承
	- 修饰方法：
		○ 不能被子类override
		

抽象类
一个类中有不确定的方法
	Abstract class 类名{} 
	
	抽象方法：
		Public abstract void 方法名（）
	- 不能被实例化：
		○ 不可以使用new关键字创建对象
		○ 但是在子类创建对象时， 抽象父类也会被JVM实例化。 
注意：
	- 不能用final声明（因为final修饰的class不能有子类）
	- 能有构造方法
	- 必须用public或procted 修饰(如果为private修饰，那么子类则无法继承，也就无法实现其 抽象方法)。默认缺省为public
	- 如果一个子类继承抽象类，那么必须实现其所有的抽象方法。
		○ 如果有未实现的抽象方法，那么子类也必须定义为abstract类 



接口
一个class中的全部方法都是抽象方法，全部属性都是全局常量。
	Interface 接口名称{
		全局常量；
		（简写）Int a = 10 == public static final int a = 10
		抽象方法；
		（简写）Void say（） == public abstract void say（）
	}
	- 接口中不能有确定的方法
	- 接口不能有static方法
	

接口的实现 implements
	- 接口可以多实现
	Class 子类 implements 父接口1，父接口2{
	}
	- 

面向接口编程思想：
这种思想是接口是定义(规范，约束)与实现(名实分离的原则)的分离。 
优点:
1、 降低程序的耦合性 （模块与模块之间的黏性）
2、 易于程序的扩展 
3、 有利于程序的维护：如 删class 



多态：
对象的多种表现形式。
	- 父类引用指向子类对象，子类就是父类的一种形态 
	- 使用：对象的类型转换：
		· 向上转型:将子类实例变为父类实例
			|- 格式:父类 父类对象 = 子类实例 ; 
			Person p1 = a；
		· 向下转型:将父类实例变为子类实例
			|- 格式:子类 子类对象 = (子类)父类实例 ; 
			Student a2 = （Student）p1；
			
	ps：
	重载: 一个类中方法的多态性体现
	重写: 子父类中方法的多态性体现。 

Instanceof
判断某个对象是否是指定类的实例 
	- 结果为boolean
	If (p instanceof Student){}


Object
	- 是所有类的父类
	Public class Person extends Object {}
	- 表示任意类型，即可接收任何的引用数据类型：
	public static void say（object）{}

toString
返回对象的字符串表示形式
	- object的toString方法：返回对象的内存地址
		Syso(p) == syso(p.toString())
	- 建议重写object的toString方法：
		Public String toString(){}



Equals
	- 对象中，"=="比较的是内存地址
	- 实现了对象上最具区别的可能等价关系
		○ 建议重写object中的equals（Object obj）方法，





可变参数
int...nums：表示的是可变参数
	- 调用时可传递0-n个数字
	- 在方法内部，可变参数是数组
	- 注意：
		○ 只能出现在参数列表的最后





Eclipse Mac中的快捷键
command+option+S: 调出快速生成代码会话框,可以选择为成员变量生成Setter/Getter方法

